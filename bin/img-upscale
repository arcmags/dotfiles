#!/bin/bash
## img-upscale ::

[[ $0 != "${BASH_SOURCE[0]}" ]] && return 0
print_help() { cat <<'HELPDOC'
Usage:
  img-upscale [option...] <image...>

Upscale and/or sharpen images with waifu2x.

Options:
  -d --dir <dir>        output directory
  -r --rdir <dir>       output directory relative to input image directory
  -m, --model <model>   upscale model (a/anime/c/cunet/p/photo, default: cunet)
  -n, --noise <level>   denoise level (-1/0/1/2/3, default=0)
  -o, --output <format> output filename format (default: %f_u%s%m%n.%t)
  -q, --quality <level> jpg quality level (0-100, default=92)
  -s, --scale <level>   upscale level (1/2/4/8/16/32, default=2)
  -J, --jpg             output to jpg file
  -P, --png             output to png file
  -Q, --quiet           print nothing to stdout
  -V, --verbose         print more verbose information
  -H, -h, --help        print help and exit

Format:
  %%    a literal %
  %F    input image file basename
  %f    input image file basename without extension
  %I    image output count, starts at 1
  %i    image output count, starts at 1, padded with zeros
  %m    first letter of upscale model
  %M    upscale model
  %n    denoise level
  %s    upscale level
  %t    output image type

Environment:
  NO_COLOR      disable colored output
  QUIET         run silently
  VERBOSE       run verbosely
HELPDOC
exit ;}
[[ $1 =~ ^(-H|-h|--help)$ ]] && print_help

# TODO: -A, -C, -P args?

## settings ::
debug=0; dryrun=0; no_color=0; quiet=0; verbose=0
bin_waifu2x='waifu2x-ncnn-vulkan'
path_models="/usr/share/$bin_waifu2x"
model=cunet; noise=0; quality=92; scale=2
output='%f_u%s%m%n.%t'
#output='F: %F  f: %f  I: %I  i: %i  M: %M  m: %m  n: %n  s: %s  t: %t'
i=1

## internal functions/variables ::
readonly -a args=("$@")
readonly -a deps=("$bin_waifu2x" identify magick)
readonly -a opts=(
    -d: --dir: -r: --rdir:
    -m: --model: -n: --noise: -o: --output: -q: --quality: -s: --scale:
    -J --jpg -P --png -H -h --help -M --nocolor -Q --quiet -V --verbose)
readonly script="$(realpath "$BASH_SOURCE")"
args_options=() args_positionals=()
dir_model=
img_out=
imgs=()
imgs_err=()
text_subbed=
img_type=
type=
rdir=
unset dir

# colors:
black=$'\e[38;5;0m'; blue=$'\e[38;5;12m'; cyan=$'\e[38;5;14m'
green=$'\e[38;5;10m'; grey=$'\e[38;5;8m'; magenta=$'\e[38;5;13m'
orange=$'\e[38;5;3m'; red=$'\e[38;5;9m' white=$'\e[38;5;15m'
yellow=$'\e[38;5;11m'; bold=$'\e[1m'; off=$'\e[0m'
clear_colors() {
    nocolor=1
    export NO_COLOR=true
    unset black blue cyan green grey magenta orange red white yellow bold off
}

# messages:
msg() { printf "$bold$blue=> $off$white%s$off\n" "$*" ;}
msg2() { printf "$bold$blue > $off$white%s$off\n" "$*" ;}
msg_error() { printf "$bold${red}E: $off$white%s$off\n" "$*" >&2 ;}
msg_good() { printf "$bold$green=> $off$white%s$off\n" "$*" ;}
msg_plain() { printf "$off$white  %s$$off\n" "$*" ;}
msg_warn() { printf "$bold${yellow}W: $off$white%s$off\n" "$*" >&2 ;}
msg_cmd() {
    local _printf='printf'; [[ -f /usr/bin/printf ]] && _printf='/usr/bin/printf'
    [[ $EUID -eq 0 ]] && printf "$bold$red #" || printf "$bold$blue $"
    printf "$off$white"; "$_printf" ' %q' "$@"; printf "$off\n"
}

# utils:
check_deps() {
    local deps_e=()
    for dep in "${deps[@]}"; do is_cmd "$dep" || deps_e+=("$dep"); done
    [[ ${#deps_e} -gt 0 ]] && msg_error "missing deps: ${deps_e[*]}"
    return ${#deps_e[@]}
}
is_cmd() { command -v "$1" &>/dev/null ;}
is_img() { [[ -f $1 ]] && identify "$1" &>/dev/null ;}

parse_args() {
    local a=0 opt= sflgs= sopts= arg="${args[0]}"
    local -a lflgs=() lopts=()
    args_options=() args_positionals=()
    bad_opt() { msg_error "unrecognized option: -${arg:2:1}" ;}
    bad_optarg() { msg_error "option requires an argument: $arg" ;}
    bad_flg() { msg_error "option does not take argument: ${arg%%=*}" ;}
    for opt in "${opts[@]}"; do case "$opt" in
        -?) sflgs="$sflgs${opt:1}" ;;
        -?:) sopts="$sopts${opt:1:1}" ;;
        *:) lopts+=("${opt:0:-1}") ;;
        *) lflgs+=("$opt") ;;
    esac; done
    while [[ -n $arg ]]; do case "$arg" in
        --) ((a++)); break ;;
        -[$sflgs]) args_options+=("$arg") ;;
        -[$sflgs]*) [[ ! $sflgs$sopts =~ ${arg:2:1} ]] && { bad_opt; return 3 ;}
            args_options+=("${arg:0:2}"); arg="-${arg:2}"; continue ;;
        -[$sopts]) [[ $((${#args[@]}-a)) -le 1 ]] && { bad_optarg; return 3 ;}
            args_options+=("$arg" "${args[((++a))]}") ;;
        -[$sopts]*) args_options+=("${arg:0:2}" "${arg:2}") ;;
        *=*) [[ " ${lflgs[*]} " =~ " ${arg%%=*} " ]] && { bad_flg; return 3 ;}
            [[ " ${lopts[*]} " =~ " ${arg%%=*} " ]] || break
            args_options+=("${arg%%=*}" "${arg#*=}") ;;
        *) if [[ " ${lflgs[*]} " =~ " $arg " ]]; then
                args_options+=("$arg")
            elif [[ " ${lopts[*]} " =~ " $arg " ]]; then
                [[ ${#args[@]} -le $((a+1)) ]] && { bad_optarg; return 3 ;}
                args_options+=("$arg" "${args[((++a))]}")
            else break; fi ;;
    esac; arg="${args[((++a))]}"; done
    args_positionals=("${args[@]:a}")
}

sub_text() {
    local i=0 found=0 repl= sub=
    text_subbed=
    for sub in "${subs[@]}"; do
        [[ ${sub:1:1} == : ]] || { msg_error "invalid sub: $sub"; return 3 ;}
    done
    while [[ $i -lt ${#text} ]]; do
        repl="${text:i:1}"
        if [[ ${text:i:1} == % ]]; then
            ((i++))
            if [[ ${text:i:1} == % ]]; then
                repl='%'
            else
                found=0; for sub in "${subs[@]}"; do
                    if [[ ${text:i:1} == ${sub:0:1} ]]; then
                        repl="${sub:2}"; ((found++))
                fi; done
                if ! ((found)); then
                    msg_error "invalid format character: ${text:i:1}"
                    return 3
                fi
                ((found)) || { msg_error "invalid format: ${text:i:1}"; return 3 ;}
        fi; fi
        text_subbed+="$repl"; ((i++))
    done
}

# error, exit, trap:
error() { msg_error "$*"; exit 3 ;}
trap_exit() { ((debug)) && msg_error '[exit]' ;}
trap_int() { printf '\n'; msg_error '[sigint]'; exit 99 ;}

## main ::
trap trap_int INT
trap trap_exit EXIT

# set from env:
[[ -n $DEBUG ]] && debug=1
[[ -n $NO_COLOR || ! -t 1 || ! -t 2 ]] && { no_color=1; clear_colors ;}
[[ -n $QUIET ]] && { quiet=1; verbose=0 ;}
[[ -n $VERBOSE ]] && { quiet=0; verbose=1 ;}

# parse args:
parse_args || exit
set -- "${args_options[@]}"
while [[ -n $1 ]]; do case "$1" in
    -d|--dir) shift; unset rdir; dir="$1" ;;
    -r|--rdir) shift; unset dir; rdir="$1" ;;
    -m|--model) shift; model="${1,,}" ;;
    -n|--noise) shift; noise="$1" ;;
    -o|--output) shift; output="$1" ;;
    -q|--quality) shift; quality="$1" ;;
    -s|--scale) shift; scale="$1" ;;
    -J|--jpg) type='jpg' ;;
    -P|--png) type='png' ;;
    -Q|--quiet) quiet=1; verbose=0 ;;
    -V|--verbose) quiet=0; verbose=1 ;;
    -M|--nocolor) no_color=1; clear_colors ;;
    -h|-H|--help) print_help ;;
esac; shift; done

# check for errors:
check_deps || exit
[[ $model =~ ^(a|anime|c|cunet|p|photo)$ ]] || error "invalid model: $model"
[[ $noise =~ ^(-1|0|1|2|3)$ ]] || error "invalid denoise level: $noise"
[[ $quality =~ ^([1-9]|[1-9][0-9]|100)$ ]] || error "invalid jpg quality: $quality"
[[ $scale =~ ^(1|2|4|16|32)$ ]] || error "invalid upscale level: $scale"

# set model directory:
case "$model" in
    a|anime) dir_model="$path_models/models-upconv_7_anime_style_art_rgb" ;;
    c|cunet) dir_model="$path_models/models-cunet" ;;
    p|photo) dir_model="$path_models/models-upconv_7_photo" ;;
esac

# check positional args:
for arg in "${args_positionals[@]}"; do
    dup=0; for i in "${imgs[@]}"; do [[ $i == $arg ]] && { dup=1; break ;}; done
    ((dup)) && continue
    is_img "$arg" || { imgs_err+=("$arg"); continue ;}
    imgs+=("$arg")
done
[[ -n $imgs_err ]] && msg_warn "image error: ${imgs_err[*]}"

# upscale images:
dir_out="$dir"
i=1
n_imgs="${#imgs[@]}"

for img in "${imgs[@]}"; do

    # get output directory:
    [[ -n ${rdir+x} && -n $rdir ]] && dir_out="$(dirname "$img")/$rdir"


    ((debug)) && { msg_warn "$img $yellow->$white $dir_out ..."; continue ;}
done

exit

i=1
n_imgs="${#imgs[@]}"
for img in "${imgs[@]}"; do

    # set format variables:
    dir=''; file="$img"; file_base="$img"; path="$img"

    if [[ $img =~ ^(.*/)(.*)$ ]]; then
        dir="${BASH_REMATCH[1]}"
        file="${BASH_REMATCH[2]}"
        file_base="${BASH_REMATCH[2]}"
    fi

    # TODO: redo this
    if [[ $file =~ ^([^.].*)\.(.*)$ ]]; then
        file_base="${BASH_REMATCH[1]}"

        # TODO: tmp type for each img
        if [[ -z $type ]]; then
            type="${BASH_REMATCH[2]}"; type="${type,,}"
            [[ $type == jpeg ]] && type=jpg
        fi

    fi
    path_base="$dir${file_base}"
    [[ -z $type ]] && type=jpg

    # format output filename:
    text="$output"
    subs=("F:$file" "f:${file_base}" "I:$i" "i:$(printf "%0${#n_imgs}d" "$i")"
        "M:$model" "m:${model:0:1}" "n:$noise" "s:$scale" "t:$type")
    sub_text || exit
    img_out="$text_subbed"
    ((i++))

    ((debug)) && { msg_warn "$img $yellow->$white $img_out"; continue ;}

    # upscale image:
    img_tmp="$(mktemp --tmpdir XXX.png)"
    cmd_waifu2x=("$bin_waifu2x" -m "$dir_model" -s "$scale" -n "$noise" -i "$img" -o "${img_tmp}")
    success=0
    ((quiet)) || msg "$img $bold$blue->$off$white $img_out"
    if ((verbose)); then
        msg_cmd "${cmd_waifu2x[@]}"
        "${cmd_waifu2x[@]}" && success=1
    else
        "${cmd_waifu2x[@]}" &>/dev/null && success=1
    fi
    if ((success)); then
        # convert to jpg:
        if [[ $ext == jpg ]]; then
            ((verbose)) && msg_cmd magick "$img_tmp" -quality "$quality" "$img_out"
            magick "$img_tmp" -quality "$quality" "$img_out"
        else
            ((verbose)) && msg_cmd cp "$img_tmp" "$img_out"
            cp "$img_tmp" "$img_out"
        fi
    else
        msg_error "waifu2x error: $img"
    fi
    rm -f "$img_tmp"
done

# vim:ft=bash
