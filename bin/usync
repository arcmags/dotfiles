#!/bin/bash
## usync ::

print_help() { cat <<'HELPDOC'
NAME
    usync - push/pull changes from remote source

SYNOPSIS
    usync <COMMAND> [OPTION...]

DESCRIPTION
    Usync is an rsync wrapper controlled via config file. Usync searches the
    current and parent directories for a .usync file and executes COMMAND.

COMMANDS
    init
        Create a new .usync file in current directory.

    push
        Push changes to remote source.

    pull
        Pull changes from remote source.

OPTIONS
    -D, --dryrun
        Perform dry run making no changes.

    -H, --help
        Display this help.

    -V, --verbose
        Show rsync command.

    -c, --config <FILE>
        Use config FILE. Don't search parent dirs if FILE does not exist.

CONFIG
    .usync - strict-yaml file defining usync repo, may contain following keys:

        dir
            Remote directory. Must be a full path. Required.

        exclude
            List of patterns to exclude via rsync --exclude option.
            See FILTER RULES section of rsync manual.

        port
            Remote port. If blank, inherit from ssh alias.

        url
            Remote repo url. May be an ssh alias. Required.

        user
            Remote user. If blank, inherit from ssh alias.

REQUIREMENTS
    rsync, ssh
HELPDOC
}

## control ::
args_rsync=('-azz' '--protect-args' '--info=copy1,del1,name1' '--delete')
arr_conf=()
conf_ssh=

lines=
cmd_ssh='ssh'
dir=
exclude=
excludes=()
conf='.usync'
host="$HOSTNAME"
n_actions=0
opt_config=
port=
deps=(rsync ssh)
url=
url_dir=
user=
args_sed=(-e 's/deleting /\o033[1;38;5;9m - \o033[0;38;5;15m/'
    -e '/ - /! s/^/\o033[1;38;5;10m + \o033[0;38;5;15m/')
is_local=false

# args:
a=0 arg="$1" args=("$@")
flg_dryrun=false
flg_init=false
flg_pull=false
flg_push=false
flg_verbose=false
flg_status=false
flg_debug=false

## functions ::
is_cmd() { command -v "$1" &>/dev/null ;}
msg() { printf "\e[1;38;5;12m=> \e[0;38;5;15m$1\e[0m\n" "${@:2}" ;}
msg2() { printf '   \e[0;38;5;15m%s\e[0m\n' "$*" ;}
msg_cmd() { printf '\e[1;38;5;12m $\e[0;38;5;15m'; printf ' %q' "$@"; printf '\n' ;}
[ $EUID -eq 0 ] && msg_cmd() { printf '\e[1;38;5;9m $\e[0;38;5;15m'; printf ' %q' "$@"; printf '\n' ;}
msg_error() { printf "\e[1;38;5;9mE: \e[0;38;5;15m$1\e[0m\n" "${@:2}" >&2 ;}
msg_warn() { printf "\e[1;38;5;11mW: \e[0;38;5;15m$1\e[0m\n" "${@:2}" >&2 ;}
error() { msg_error "$@"; exit 5 ;}


## main ::
while [ -n "$arg" ]; do case "$arg" in
    init) flg_init=true; arg="${args[((++a))]}"; ((n_actions++)) ;;
    pull) flg_pull=true; arg="${args[((++a))]}"; ((n_actions++)) ;;
    push) flg_push=true; arg="${args[((++a))]}"; ((n_actions++)) ;;
    --debug) flg_debug=true; arg="${args[((++a))]}" ;;
    -D|--dryrun) flg_dryrun=true; arg="${args[((++a))]}" ;;
    -V|--verbose) flg_verbose=true; arg="${args[((++a))]}" ;;
    -H|--help) print_help; exit 0 ;;
    -c|--config)
        [ $# -le $((a+1)) ] && error "arg required: $arg"
        opt_config="${args[((++a))]}"; arg="${args[((++a))]}" ;;
    -[DVH]*)
        [[ ! "${arg:2:1}" =~ [DVHc] ]] && error "unknown option: ${arg:2:1}"
        args[a--]="-${arg:2}"; arg="${arg:0:2}" ;;
    -[c]*) args[a]="${arg:2}"; arg="${arg:0:2}"; ((a--)) ;;
    --) ((a++)); break ;;
    *) break ;;
esac; done
args=("${args[@]:a}")

# dependency error:
for dep in "${deps[@]}"; do is_cmd "$dep" || error "missing dep: $dep"; done

# args error:
[ ${#args[@]} -gt 0 ] && error "unknown args: ${args[*]}"
[ $n_actions -eq 0 ] || [ $n_actions -gt 1 ] && error 'too many/no actions given'

# set config file from command line option:
conf="${opt_config:-$conf}"

# resolve hostname:
[ -f '/etc/hostname' ] && host="$(cat /etc/hostname)"
[ -f '/etc/hostname-' ] && host="$(cat /etc/hostname-)"

if [ "$flg_init" = true ]; then
    # create new .usync file in current directory:
    [ -f "$conf" ] && error "already exists: $conf"
    touch "$conf"
    { printf '## %s ::\n\n' "$(realpath "$conf")"
    printf 'dir: %s\nurl: localhost\n\nexclude:\n- /local\n- .git\n\n' "$PWD"
    printf '# vim:ft=yaml\n' ;} > "$conf"
    exit 0
fi

# config file from command line option not found:
[ -n "$opt_conf" ] && [ ! -f "$conf" ] && error "file not found: $conf"

# cd to nearest parent directory that contains config file:
[ -z "$opt_config" ] && { while [ ! -f "$conf" ] && [ "$PWD" != '/' ]; do cd ..; done ;}
[ ! -f "$conf" ] && error 'not a usync repository'

# parse config:
mapfile -t lines < <(sed -E -e 's/(^\s+|\s+$)//g' -e '/^(#|$|-$)/d' "$conf")
in_exclude=false
for line in "${lines[@]}"; do
    if [ "$in_exclude" = true ]; then
        [[ "$line" =~ ^-\ +(.*) ]] && excludes+=("${BASH_REMATCH[1]}") && continue
        in_exclude=false
    fi
    [[ "$line" =~ ^dir:\ +(.*) ]] && dir="${BASH_REMATCH[1]}" && continue
    [[ "$line" =~ ^port:\ +(.*) ]] && port="${BASH_REMATCH[1]}" && continue
    [[ "$line" =~ ^url:\ +(.*) ]] && url="${BASH_REMATCH[1]}" && continue
    [[ "$line" =~ ^user:\ +(.*) ]] && user="${BASH_REMATCH[1]}" && continue
    [ "$line" = 'exclude:' ] && in_exclude=true && continue
done
[ "${dir:0:1}" = '~' ] && dir="$HOME${dir:1}"
[ "${dir: -1}" = '/' ] && dir="${dir:0:-1}"

# config errors:
[ -z "$url" ] && error 'no url'
[ -z "$dir" ] && error 'no directory'
if [ -n "$port" ]; then
    [[ $port =~ ^[1-9][0-9]*$ ]] && [ $port -lt 65536 ] || error "invalid port: $port"
fi

# print debugging info:
if [ "$flg_debug" = true ]; then
    printf "repo: $PWD\n"
    printf "dir: $dir\n"
    printf "url: $url\n"
    printf "user: $user\n"
    printf "port: $port\n"
    printf "excludes:\n"
    for e in "${excludes[@]}"; do printf "  $e\n"; done
    exit 0
fi

# check if remote is on localhost:
if [[ "$url" =~ ^localhost|$host|127.0.0.1$ ]]; then
    [ "$(realpath "$dir")" = "$(realpath "$PWD")" ] && msg_warn 'remote' && exit 0
    is_local=true
fi

# check ssh config for port and user settings, set ssh command passed to rsync:
if [ "$is_local" != true ]; then
    conf_ssh="$(ssh -G "$url")"
    [ -n "$port" ] && [ "$(grep -Po '^port \K.*' <<<"$conf_ssh")" != "$port" ] && cmd_ssh+=" -p $port"
    [ -n "$user" ] && [ "$(grep -Po '^user \K.*' <<<"$conf_ssh")" != "$user" ] && cmd_ssh+=" -l $user"
    [ "$cmd_ssh" != 'ssh' ] && args_rsync+=('-e' "$cmd_ssh")
fi

# add excludes to rsync args:
for exclude in "${excludes[@]}"; do args_rsync+=('--exclude' "$exclude"); done

[ "$flg_dryrun" = true ] && args_rsync+=('--dry-run')
[ "$is_local" = true ] && url_dir="$dir" || url_dir="$url:$dir"

if [ "$flg_push" = true ]; then
    if [ "$is_local" = true ]; then
        mkdir -p "$dir"
    else
        args_rsync+=('--rsync-path' "mkdir -p '$dir' && rsync")
    fi
    args_rsync+=("$PWD/" "$url_dir")
    msg "pushing %s to %s ..." "$(printf '%q' "$PWD/")" "$(printf '%q' "$url_dir/")"
fi

if [ "$flg_pull" = true ]; then
    args_rsync+=("$url_dir/" "$PWD")
    msg "pulling %s from %s ..." "$(printf '%q' "$PWD/")" "$(printf '%q' "$url_dir/")"
fi

if [ "$flg_dryrun" = true ]; then
    args_sed=(-e 's/deleting /\o033[1;38;5;11m - \o033[0;38;5;15m/'
        -e '/ - /! s/^/\o033[1;38;5;11m + \o033[0;38;5;15m/')
fi

[ "$flg_verbose" = true ] && msg_cmd rsync "${args_rsync[@]}"

rsync "${args_rsync[@]}" | sed -E -e '/\/$/d' -e '/^created /d' "${args_sed[@]}"

[ "$flg_dryrun" = true ] && msg_warn 'dryrun'

# vim:ft=bash
