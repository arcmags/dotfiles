#!/bin/bash
## uqemu ::

[[ $0 != "${BASH_SOURCE[0]}" ]] && return 0
print_help() { cat <<'HELPDOC'
Usage:
  uqemu [option...] <image/iso...> [-- [qemu-option...]]

Launch qemu-system-x86_64 with attached raw image and iso files. Automatically
detect/enable KVM and bridged networking support.

Options:
  -m <memory>           qemu RAM size
  -M, --nocolor         disable colored output
  -V, --verbose         print more verbose information
  -H, --help            print help

Files:
  $XDG_CONFIG_HOME/uqemu/uqemu.conf     config file, bash script

Environment:
  NO_COLOR          disable colored output
  XDG_CONFIG_HOME   config file location
HELPDOC
exit "${1:-0}" ;}; [[ $1 =~ ^(-H|--help)$ ]] && print_help

## settings ::
debug=0 nocolor=0 quiet=0 verbose=0
args_qemu=(-vga virtio -display gtk,show-cursor=yes)
mem_qemu=4G

## internal functions/variables ::
readonly -a args=("$@"); args_options=() args_positionals=()
readonly -a deps=(qemu-system-x86_64)
readonly -a opts=(-m: -M --nocolor -V --verbose -H --help)
readonly file_config="${XDG_CONFIG_HOME:-$HOME/.config}/uqemu/uqemu.conf"
cmd=(qemu-system-x86_64)
bridge=br0
ext=
i=0

# colors, control sequences:
readonly clear_line=$'\e[2K'
black=$'\e[38;5;0m' blue=$'\e[38;5;12m' blue2=$'\e[38;5;4m' cyan=$'\e[38;5;14m'
cyan2=$'\e[38;5;6m' green=$'\e[38;5;10m' green2=$'\e[38;5;2m' grey=$'\e[38;5;8m'
magenta=$'\e[38;5;13m' magenta2=$'\e[38;5;5m' orange=$'\e[38;5;3m' red=$'\e[38;5;9m'
red2=$'\e[38;5;1m' white=$'\e[38;5;15m' white2=$'\e[38;5;7m' yellow=$'\e[38;5;11m'
bold=$'\e[1m' off=$'\e[0m'
clear_colors() {
    export NO_COLOR=1 nocolor=1
    unset black blue blue2 cyan cyan2 green green2 grey magenta magenta2
    unset orange red red2 white white2 yellow bold off
}

# messages:
bin_printf() { printf "$@" ;}
[[ -f /usr/bin/printf ]] && bin_printf() { /usr/bin/printf "$@" ;}
msg() { printf "$bold$blue=> $off$white%s$off\n" "$*" ;}
msg2() { printf "$bold$blue > $off$white%s$off\n" "$*" ;}
msg2_warn() { printf "$bold${yellow} > $off$white%s$off\n" "$*" >&2 ;}
msg_error() { printf "$bold${red}E: $off$white%s$off\n" "$*" >&2 ;}
msg_good() { printf "$bold$green=> $off$white%s$off\n" "$*" ;}
msg_plain() { printf "$off$white   %s$off\n" "$*" ;}
msg_warn() { printf "$bold${yellow}W: $off$white%s$off\n" "$*" >&2 ;}
msg_cmd() { local _p="$bold$blue:$"; [[ $EUID -eq 0 ]] && _p="$bold$red:#"
    printf "$_p$off$white $(print_cmd "$@")$off\n" ;}
msg_debug() { printf "$bold${yellow}-- $off$white%s$off\n" "$*" >&2 ;}
msg_input() { local _txt=''; [[ -n $1 ]] && _txt="$1 "
    read -erp "$bold$green:$off$white $_txt$off" "${2:-reply}" ;}
print_cmd() { printf "%q$([[ -n $2 ]] && bin_printf ' %q' "${@:2}")" "$1" ;}

# utils:
cmd() {
    [[ -z $1 ]] && return
    ((verbose)) && msg_cmd "$@"
    "$@"
}

cmd_null() {
    [[ -z $1 ]] && return
    ((verbose)) && msg_cmd "$@"
    "$@" &>/dev/null
}

check_deps() {
    local _dep= _deps=("${deps[@]}") _errs=(); (($#)) && _deps=("$@")
    for _dep in "${_deps[@]}"; do is_cmd "$_dep" || _errs+=("$_dep"); done
    ((${#_errs[@]})) && msg_error "missing deps: ${_errs[*]}"
    return ${#_errs[@]}
}
check_internet() { ping -q -c1 -W2 google.com &>/dev/null ;}
is_cmd() { command -v "$1" &>/dev/null ;}
is_img() { [[ -f $1 ]] && identify "$1" &>/dev/null ;}
is_port() { [[ $1 =~ ^[1-9][0-9]*$ && $1 -lt 65536 ]] ;}

parse_args() {
    local _a=0 _opt= _sflgs= _sopts= _arg="${args[0]}" _nobreak=0
    local -a _lflgs=() _lopts=()
    args_options=() args_positionals=()
    [[ $1 == nobreak ]] && _nobreak=1
    _eopt() { msg_error "unrecognized option: -${_arg:2:1}" ;}
    _eoptarg() { msg_error "option requires an argument: $_arg" ;}
    _eflg() { msg_error "option does not take argument: ${_arg%%=*}" ;}
    for _opt in "${opts[@]}"; do case "$_opt" in
        -?) _sflgs="$_sflgs${_opt:1}" ;;
        -?:) _sopts="$_sopts${_opt:1:1}" ;;
        *:) _lopts+=("${_opt:0:-1}") ;;
        *) _lflgs+=("$_opt") ;;
    esac; done
    while [[ -n $_arg ]]; do case "$_arg" in
        --) ((_a++)); break ;;
        -[$_sflgs]) args_options+=("$_arg") ;;
        -[$_sflgs]*) [[ ! $_sflgs$_sopts =~ ${_arg:2:1} ]] && { _eopt; return 3 ;}
            args_options+=("${_arg:0:2}") _arg="-${_arg:2}"; continue ;;
        -[$_sopts]) [[ $((${#args[@]}-_a)) -le 1 ]] && { _eoptarg; return 3 ;}
            args_options+=("$_arg" "${args[((++_a))]}") ;;
        -[$_sopts]*) args_options+=("${_arg:0:2}" "${_arg:2}") ;;
        *=*) [[ " ${_lflgs[*]} " =~ " ${_arg%%=*} " ]] && { _eflg; return 3 ;}
            [[ " ${_lopts[*]} " =~ " ${_arg%%=*} " ]] || break
            args_options+=("${_arg%%=*}" "${_arg#*=}") ;;
        *) if [[ " ${_lflgs[*]} " =~ " $_arg " ]]; then
                args_options+=("$_arg")
            elif [[ " ${_lopts[*]} " =~ " $_arg " ]]; then
                [[ ${#args[@]} -le $((_a+1)) ]] && { _eoptarg; return 3 ;}
                args_options+=("$_arg" "${args[((++_a))]}")
            elif ((_nobreak)); then args_options+=("$_arg")
            else break; fi ;;
    esac; _arg="${args[((++_a))]}"; done
    args_positionals+=("${args[@]:_a}")
}

# cleanup, error, exit, trap:
cleanup() { for t in "${tmp_files[@]}"; do [[ -f $t ]] && rm "$t"; done ;}
error() { msg_error "$*"; exit 3 ;}
trap_exit() { ((debug)) && msg_debug '[exit]' ;}
trap_int() { printf '\n'; ((debug)) && msg_debug '[sigint]'; exit 99 ;}

## main ::
trap trap_int INT
trap trap_exit EXIT

# source config file:
[[ -f $file_config ]] && source "$file_config"

# set from env:
[[ -n $NO_COLOR || ! -t 1 || ! -t 2 ]] && clear_colors
[[ -n $DEBUG ]] && debug=1 quiet=0 verbose=1

# parse args:
parse_args || exit
set -- "${args_options[@]}"
while [[ -n $1 ]]; do case "$1" in
    -m) shift; mem_qemu="$1" ;;
    -M|--nocolor) clear_colors ;;
    -V|--verbose) quiet=0 verbose=1 ;;
    -H|--help) print_help ;;
esac; shift; done

# errors:
check_deps || exit
[[ ${#args_positionals[@]} -eq 0 ]] && error 'no image'
[[ $mem_qemu =~ ^[1-9][0-9]*[MG]?$ ]] || error "$mem_qemu: bad memory size"

# add default args:
((verbose)) && msg2 "default args: $(print_cmd "${args_qemu[@]}")"
cmd+=("${args_qemu[@]}")

# check/enable KVM:
if grep -Eqs '\b(vmx|svm|0xc0f)\b' /proc/cpuinfo; then
    ((verbose)) && msg2 "KVM: enabled"
    cmd+=(-enable-kvm)
else
    ((verbose)) && msg2_warn "KVM: disabled"
fi

# check/enable bridged networking:
if [[ -d "/sys/class/net/$bridge" ]] && grep -qs "^allow $bridge$" /etc/qemu/bridge.conf; then
    ((verbose)) && msg2 'network: bridged'
    cmd+=(-nic bridge,model=virtio-net-pci)
else
    ((verbose)) && msg2 'network: user-mode'
fi

# set qemu memory:
((verbose)) && msg2 "memory: $mem_qemu"
cmd+=(-m "$mem_qemu")

# set qemu args from positionals:
i=0
while [[ $i -lt ${#args_positionals[@]} ]]; do
    arg="${args_positionals[i]}"
    # add remaining positionals as raw qemu args:
    if [[ $arg == -- ]]; then
        ((verbose)) && msg2 "additional args: $(print_cmd "${args_positionals[@]:i+1}")"
        cmd+=("${args_positionals[@]:i+1}")
        break
    fi
    # add image/iso file:
    [[ -f $arg ]] || error "$arg: file not found"
    ext="${arg##*.}" ext="${ext,,}"
    if [[ $ext == img ]]; then
        ((verbose)) && msg2 "drive: $arg"
        cmd+=(-drive "file=$arg,format=raw")
    elif [[ $ext == iso ]]; then
        ((verbose)) && msg2 "iso: $arg"
        cmd+=(-cdrom "$arg" -boot order=d)
    else
        error "$arg: unsupported file type"
    fi
    ((i++))
done

((debug)) && { msg_debug "$(print_cmd "${cmd[@]}")"; exit ;}
verbose=1 cmd "${cmd[@]}"

# vim:ft=bash
